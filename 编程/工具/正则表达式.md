# 正则表达式

### 与

 `\d` 只能匹配到一个字符，而`\d\d` 就匹配到两个连续的数字。

`reg{m,n}` 内容连续匹配 `reg` 规则 至少 m 次，至多 n 次。

![image-20231108020051956](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231108020051956.png)



### 或

`reg1|reg2|reg3` 表示，内容符合 `reg1`、`reg2`、`reg3` 之一即可立即匹配。但是要注意或操作，具有短路效应，即如果前者匹配了，就被忽略后续字符的匹配。

`(\d+\.\d+)|(\d+)`，通过 `()` 来确保将两部分视为独立正则表达式。



`c1|c2|c3|...|cn`可以简写为`[c1c2c3c4...cn]`，其中`c1`等都是单字符。`[a-f]`表示`[abcdef]`，即`a|b|c|d|e|f`



`^[ap]`表示匹配除 `a` 或 `p` 字符以外的所有字符

![image-20231109001254125](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231109001254125.png)

`\d+\.\d+`匹配小数，注意`.`为正则语法的特殊字符，必须加上`\`表示转义。

### 贪婪模式

默认情况下会匹配尽可能多的字符。

![image-20231109001858639](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231109001858639.png)

如果希望匹配尽可能少的字符，可以使用`?`。

`?`的三种含义

- 量词：`reg?`
- 位置匹配：`(?=regExp)`
- 懒惰模式：紧跟在量词的后面

### 位置匹配

**位置匹配**的特点是：匹配的内容为空字符，包括以下三类：

- 行

  - 行首`^`，从行首开始匹配，如果未开启多行模式，那么只会考虑第一行
  - 行尾`$`

- 单词

  - 单词边界`\b`：在我们汉语中，并没有 单词的概念，所以 `\b` 是无法匹配的。
  - 非单词边界`\B`：在所有位置中去除单词边界后所剩的位置

- 正则位置

  - `?=`：符合reg的前方位置

    ![image-20231108123056033](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231108123056033.png)

  - `?<=`：符合reg的后方位置，`(?<=a)r`匹配`a`字符后面的`r`字符

  - `?!`：不符合reg的前方位置

    ![image-20231108123227386](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231108123227386.png)

    `h(?!o)`：匹配不在`o`字符前方的`h`字符

    ![image-20231108123308642](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231108123308642.png)

  - `?<!`：不符合reg的后方位置



### 分组

`()` 可以创建分组，分组可以方便获取到局部正则匹配的内容。

`a[vm]`就没有分组，在获取匹配结果后，只能通过`group(0)`获取到`av`。而`a([vm])`就有一个分组，在获取匹配结果后，可以通过`group(0)`获取到整个匹配结果`av`，也可以通过`group(1)`获取到局部匹配结果`v`



我们可以从匹配结果中，提取出我们想要的结果，例如提取书名：

~~~dart
void main() {
  String src = '鲁迅创作了《狂人日记》，是中国现代文学史第一篇白话文小说。'
      '《诗经》是中国古代诗歌开端，最早的一部诗歌总集。';
  RegExp exp = RegExp(r'《(.*?)》');
  Iterable<RegExpMatch> allMatches = exp.allMatches(src);

  for (RegExpMatch match in allMatches) {
    print("match:${match.group(1)}");
  }
}
~~~



根据 `md` 的规则可以很轻松地通过 `!\[.*\](\(.*?\))` 正则匹配到图片链接内容。



多个括号嵌套时，分组规则为：从左到右数 左括号 ，是第几个，就是第几组

![image.png](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/aa8b5c9c772b4366b2ad23ff7fd0428dtplv-k3u1fbpfcp-jj-mark1890000q75.webp)



我们可以通过`(?<name>reg)`正则语法，为分组起名字。

~~~dart
const reg = r'(\d{1,4})年(?<月份>\d{1,2})月(\d{1,2})';
RegExp exp = RegExp(reg);
Iterable<RegExpMatch> allMatches = exp.allMatches(src);
for (RegExpMatch match in allMatches) {
    String? month = match.namedGroup("月份");
    print("====match:$month");
    print("====groupNames:${match.groupNames}");
}

~~~



有时候，我们需要基于前面匹配的内容，对后面的匹配进行限制。也就是说，后续的匹配规则需要依赖于前面匹配的内容。比如，匹配前后一致的标签`<h1></h1>`。我们可以使用**反向引用**语法来完成上述需求

 如下，通过`\1` 就可以引用第一组的匹配结果

![image-20231109151920538](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231109151920538.png)

反向引用也支持命名的方式：`\k<name>`

![image-20231109152048648](C:/Users/AtsukoRuo/Desktop/note/框架 中间件/Flutter/assets/image-20231109152048648.png)



有时候我们加括号只是为了表示独立，并不想把它视为 **组**，这时可以使用特定的语法 `(?:reg)` 表示不捕获组。例如，`'a(?:[vm])'`

