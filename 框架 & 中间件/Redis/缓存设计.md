# 缓存设计

## 内存

可通过执行info memory 命令获取内存相关指标

| 指标                    | 含义                                                         |
| :---------------------- | :----------------------------------------------------------- |
| used_memory             | 是从Redis的角度得到的量，他表示的是Redis分配器分配的内存总量。 |
| used_memory_rss         | 表示Redis进程占据操作系统的内存，与top及ps命令看到的值是一致的。这个值除了包含分配器分配的内存之外，还包括了因为内存碎片、内存对齐引入的开销 |
| used_memory_peak        | redis的内存消耗峰值(以字节为单位)，即历史使用记录中redis使用内存峰值。 |
| used_memory_peak_perc   | 使用内存达到峰值内存的百分比，used_memory/ used_memory_peak) *100%，即当前redis使用内存/历史使用记录中redis使用内存峰值*100% |
| used_memory_overhead    | Redis为了维护数据集的内部机制所需的内存开销，包括所有客户端输出缓冲区、查询缓冲区、AOF重写缓冲区和主从复制的backlog。 |
| used_memory_startup     | Redis服务器启动时消耗的内存                                  |
| used_memory_dataset     | 数据实际占用的内存大小，即used_memory-used_memory_overhead   |
| total_system_memory     | 整个系统内存                                                 |
| used_memory_lua         | Lua脚本存储占用的内存                                        |
| maxmemory               | Redis实例的最大内存配置                                      |
| maxmemory_policy        | 当达到maxmemory时的淘汰策略                                  |
| mem_fragmentation_ratio | 碎片率，used_memory_rss/ used_memory。                       |
| mem_allocator           | 内存分配器                                                   |

需要重点关注的指标有`mem_fragmentation_ratio`

- 当`mem_fragmentation_ratio>1`时，说明有内存碎片
- 当`mem_fragmentation_ratio<1`时，说明正在使用虚拟内存



Redis进程内消耗主要包括：自身内存、对象内存、缓冲内存、内存碎片

- 自身内存可以忽略不计
- 对象内存是Redis内存占用最大的一块，存储着用户所有的数据
- 缓冲内存主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区
- Redis默认的内存分配器采用jemalloc，可选的分配器还有：glibc、 tcmalloc。jemalloc采用分层固定块的策略。比如当保存5KB对象时，jemalloc可能会采用8KB的块存储，而剩下的3KB 空间变为了内存碎片不能再分配给其他对象存储。



Redis使用`maxmemory`参数限制最大可用的对象内存（默认是尽可能地使用所有可用内存）。值得注意的是，maxmemory限制的是Redis实际使用的内存量，也就是 used_memory统计项对应的内存。这也就是说，输出缓冲区/Lua缓存等等不受maxmemory限制，但却考虑在maxmemory内。此外，还可以通过`config set maxmemory`进行动态修改。

 

Redis的内存回收机制主要体现在以下两个方面：

- 删除到达过期时间的键对象
- 内存使用达到maxmemory上限

对于第一个方面，Redis采用以下机制，来实现过期键的内存回收。

- 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。但占用系统资源多，而且不高效。

- 惰性删除：惰性删除用于当客户端读取带有超时属性的键时，如果已 经超过键设置的过期时间，会执行删除操作并返回空值。但是这有内存泄露的问题，即过期键一直不会被访问到
- Redis内部维护一个定时任务，默认每秒运行10次（通过配置`hz`设置）。在定时任务中，执行删除键的操作**redis.c/activeExpireCycle**
  1. 循环遍历全部redisDb，随机抽取20个键值，如果发现过期就直接删除。
  2. 判断20个键值中的25%(也就是5个)是否过期。如果小于等于25%，则退出当前redisDb的循环，继续下一个redisDb
  3. 如果大于25%，继续抽取20个键值进行循环，每次判断总的执行时间是否超过25毫秒
     - 超过25毫秒，过期进入快模式(超时时间会变短，1ms)
     - 没超过25毫秒，则退出当前redisDb的循环，继续下一个redisDb



当Redis所用内存达到`maxmemory`上限时，就会触发相应的溢出控制策略：

- `noeviction`：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息，此时Redis只响应读操作。
- `volatile-lru`：根据LRU算法删除设置了expire属性的键（无论它是否过期），直到腾出足够空间为止。如果没有可删除的键对象，回退到`noeviction`策略。
- `allkeys-lru`：根据LRU算法删除键，无论数据是否设置了expire属性， 直到腾出足够空间为止。
- `allkeys-random`：随机删除所有键
- `volatile-random`：随机删除设置了expire属性的键
- `volatile-ttl`：根据键值对象的`ttl`属性，删除最近将要过期数据。如果没有，回退到`noeviction`策略。





 具体策略受`maxmemory-policy`参数控制，内存溢出控制策略可以采用`config set maxmemory -policy {policy}`来动态配置。

每次Redis执行命令时都会检查是否满足maxmeory参数的约束。





降低Redis内存使用最直接的方式就是分别缩减键（key）和值（value）的长度：

- 尽量使用短名称来命名键

- 可以通过把业务对象序列化成二进制数组并放入Redis中，来减少值的长度。此外，应该选择更高效的序列化工具来尽可能地压缩长度

  ![image-20240114214752526](assets/image-20240114214752526.png)

  

  除了存储二进制数据之外，还可以存储json、xml格式的文本数据。这种方式优点是方便调试和跨语言，但是对于内存的要求更高，可以考虑使用一些字符串压缩算法。





我们也可以减少键的数量，例如，把大量键分组映射到多个hash结构中

- hash的field可用于记录原始key字符串
- hash的value保存原始值对象

![image-20240114225931556](assets/image-20240114225931556.png)

通过这个测试数据，可以说明ziplist编码的hash类型：

- 更节约内存。
- 写入更耗时

这样做的坏处是hash重构后所有的键，无法再使用超时（expire）和LRU淘汰机制自动删除。但开发人员可以存储每个对象写入的时间，再通过定时任务使用hscan命令扫描数据，找出hash内超时的数据项删除即可。



## 缓存

Redis最主要的作用就是作为系统的缓存层，它的优点如下：

- 缓存数据库的读结果，降低数据库的负载，同时优化整个IO链的响应时间

它的缺点如下：

- 代码维护成本：加入缓存后，需要同时处理缓存层和存储层的逻辑
- 运维成本
- 数据不一致风险

### 缓存的更新策略

- `maxmemory-policy`所指定的更新策略
- `expire`命令
- 在向数据库写入数据时，通过消息系统通知缓存进行更新。这一套逻辑由程序员负责实现。

![image-20240118224636698](assets/image-20240118224636698.png)

对于一致性要求高的业务，推荐使用主动更新策略。而对一致性不敏感的业务，使用`expire`或者`maxmeory-policy`即可。

### 缓存粒度

缓存粒度回答这个问题：对于从数据库中获取的数据，缓存哪些列？

![image-20240118225013885](assets/image-20240118225013885.png)

### 缓存穿透

缓存穿透是指查询一个根本不存在的数据，在缓存层和存储层中都不会命中。

缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。基本原因是：

- 一些恶意攻击、爬虫等造成大量空命中。
- 自身业务代码或者数据出现了问题

解决方案有两种

| 方案       | 原理                                     | 优势           | 劣势           | 适用场景     |
| ---------- | ---------------------------------------- | -------------- | -------------- | ------------ |
| 缓存空对象 | 存储层返回空对象，缓存层保存这个空对象。 | 代码维护简单   | 占用缓存空间多 | 数据频繁变化 |
| 布隆过滤器 | 在缓存层前，添加布隆过滤器               | 占用缓存空间少 | 代码逻辑负责   | 数据相对固定 |

### 无底洞优化

当添加大量节点做水平扩容时，键值对会分布到更多的节点上。这就导致批量操作涉及到更多的节点，相应地网络IO时间增加。这是分布式系统无法避免的问题，我们只能从IO层入手解决这个问题。

- **串行命令**，直接将命令依次发送出去，时间复杂度为$\Omicron(keys)$
- **串行IO**，Smart客户端会保存slot和节点的对应关系，这样就得到每个节点的key子列表，之后依次对每个节点执行mget或者Pipeline操作，时间复杂度为$\Omicron(nodes)$
- **并行IO**，在串行IO的基础上，并行地发送IO请求
- **hash_tag**，将多个key强制分配到 一个节点上，这会出现数据倾斜的情况

### 缓存雪崩

缓存雪崩的英文原意是stampeding herd（奔逃的野牛），指的是缓存层宕掉后，流量会像奔逃的野牛一样，打向后端存储。可以从以下三方面入手

- 保证缓存层服务高可用性
- 依赖隔离组件，为后端限流并降级。

### 热点Key重建优化



- 当前key是一个热点key
- 重建缓存不能在短时间完成，例如复杂的SQL

在缓存失效的瞬间，有大量线程来重建缓存，造成 后端负载加大。

解决方案是

- 分布式锁

- 永远不过期，一方面在Redis中并不设置过期时间，另一方面，在客户端实现逻辑过期时间

  ~~~java
  String get(String key) {
      V v = redis.get(key);
      String value = v.getValue();
      
      long logicTimeout = v.getLogicTimeout();
  	// 如果逻辑过期时间小于当前时间，开始后台构建
  	if (v.logicTimeout <= System.currentTimeMillis()) {
  		String mutexKey = "mutex:key:" + key;
  		if (redis.set(mutexKey, "1", "ex 180", "nx")) {
  			// 重构缓存
  			threadPool.execute(new Runnable() {
                  public void run() {
                  String dbValue = db.get(key);
                  redis.set(key, (dbvalue,newLogicTimeout));
                  redis.delete(mutexKey);
                  }
              });
  		}
  	}
  	return value;
  }
  
  ~~~

  

- ![image-20240118233740523](assets/image-20240118233740523.png)

